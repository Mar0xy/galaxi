// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `cmp`, `eq`, `get_cached_icon_path`, `get_info`, `get_install_directory_name`, `get_status_file_path`, `get_stripped_name`, `get_thumbnail_path`, `is_dlc_installed`, `is_installed`, `is_update_available`, `load_game_info`, `new`, `partial_cmp`, `save_game_info`, `set_info`, `set_install_dir`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Game>>
abstract class Game implements RustOpaqueInterface {
  String get category;

  List<Dlc> get dlcs;

  PlatformInt64 get id;

  String get imageUrl;

  String get installDir;

  Map<String, String> get md5Sum;

  String get name;

  String get platform;

  String get url;

  set category(String category);

  set dlcs(List<Dlc> dlcs);

  set id(PlatformInt64 id);

  set imageUrl(String imageUrl);

  set installDir(String installDir);

  set md5Sum(Map<String, String> md5Sum);

  set name(String name);

  set platform(String platform);

  set url(String url);
}

/// Represents a DLC for a game
class Dlc {
  final PlatformInt64 id;
  final String name;
  final String title;
  final String imageUrl;

  const Dlc({
    required this.id,
    required this.name,
    required this.title,
    required this.imageUrl,
  });

  @override
  int get hashCode =>
      id.hashCode ^ name.hashCode ^ title.hashCode ^ imageUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Dlc &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          title == other.title &&
          imageUrl == other.imageUrl;
}

class DlcInfo {
  final String? version;

  const DlcInfo({
    this.version,
  });

  static Future<DlcInfo> default_() =>
      RustLib.instance.api.crateApiGameDlcInfoDefault();

  @override
  int get hashCode => version.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DlcInfo &&
          runtimeType == other.runtimeType &&
          version == other.version;
}

/// Game information stored in JSON
class GameInfo {
  final String? version;
  final Map<String, DlcInfo> dlcs;
  final bool? showFps;
  final bool? useGamemode;
  final bool? useMangohud;
  final String? variable;
  final String? command;
  final String? customWine;
  final bool? hidden;

  const GameInfo({
    this.version,
    required this.dlcs,
    this.showFps,
    this.useGamemode,
    this.useMangohud,
    this.variable,
    this.command,
    this.customWine,
    this.hidden,
  });

  static Future<GameInfo> default_() =>
      RustLib.instance.api.crateApiGameGameInfoDefault();

  @override
  int get hashCode =>
      version.hashCode ^
      dlcs.hashCode ^
      showFps.hashCode ^
      useGamemode.hashCode ^
      useMangohud.hashCode ^
      variable.hashCode ^
      command.hashCode ^
      customWine.hashCode ^
      hidden.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GameInfo &&
          runtimeType == other.runtimeType &&
          version == other.version &&
          dlcs == other.dlcs &&
          showFps == other.showFps &&
          useGamemode == other.useGamemode &&
          useMangohud == other.useMangohud &&
          variable == other.variable &&
          command == other.command &&
          customWine == other.customWine &&
          hidden == other.hidden;
}
