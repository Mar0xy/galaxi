// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/account.dart';
import 'api/config.dart';
import 'api/download.dart';
import 'api/dto.dart';
import 'api/game.dart';
import 'api/simple.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiSimpleInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => -1898248573;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rust_lib_minigalaxy_flutter',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<DownloadManager> crateApiDownloadDownloadManagerDefault();

  String crateApiGameGameAutoAccessorGetCategory({required Game that});

  List<Dlc> crateApiGameGameAutoAccessorGetDlcs({required Game that});

  PlatformInt64 crateApiGameGameAutoAccessorGetId({required Game that});

  String crateApiGameGameAutoAccessorGetImageUrl({required Game that});

  String crateApiGameGameAutoAccessorGetInstallDir({required Game that});

  Map<String, String> crateApiGameGameAutoAccessorGetMd5Sum(
      {required Game that});

  String crateApiGameGameAutoAccessorGetName({required Game that});

  String crateApiGameGameAutoAccessorGetPlatform({required Game that});

  String crateApiGameGameAutoAccessorGetUrl({required Game that});

  void crateApiGameGameAutoAccessorSetCategory(
      {required Game that, required String category});

  void crateApiGameGameAutoAccessorSetDlcs(
      {required Game that, required List<Dlc> dlcs});

  void crateApiGameGameAutoAccessorSetId(
      {required Game that, required PlatformInt64 id});

  void crateApiGameGameAutoAccessorSetImageUrl(
      {required Game that, required String imageUrl});

  void crateApiGameGameAutoAccessorSetInstallDir(
      {required Game that, required String installDir});

  void crateApiGameGameAutoAccessorSetMd5Sum(
      {required Game that, required Map<String, String> md5Sum});

  void crateApiGameGameAutoAccessorSetName(
      {required Game that, required String name});

  void crateApiGameGameAutoAccessorSetPlatform(
      {required Game that, required String platform});

  void crateApiGameGameAutoAccessorSetUrl(
      {required Game that, required String url});

  Future<AccountManager> crateApiAccountAccountManagerDefault();

  Future<AccountDto> crateApiSimpleAddCurrentAccount(
      {required String refreshToken});

  Future<String> crateApiSimpleAuthenticate(
      {String? loginCode, String? refreshToken});

  Future<bool> crateApiSimpleCanConnect();

  Future<void> crateApiSimpleCancelDownload({required PlatformInt64 gameId});

  Future<bool> crateApiSimpleCheckForUpdate({required PlatformInt64 gameId});

  Future<Config> crateApiConfigConfigDefault();

  Future<DlcInfo> crateApiGameDlcInfoDefault();

  Future<GameInfo> crateApiGameGameInfoDefault();

  Future<AccountDto?> crateApiSimpleGetActiveAccount();

  Future<List<DownloadProgressDto>> crateApiSimpleGetActiveDownloads();

  Future<List<AccountDto>> crateApiSimpleGetAllAccounts();

  Future<ConfigDto> crateApiSimpleGetConfig();

  Future<bool> crateApiSimpleGetDarkTheme();

  Future<DownloadProgressDto?> crateApiSimpleGetDownloadProgress(
      {required PlatformInt64 gameId});

  Future<GameInfoDto> crateApiSimpleGetGameInfo(
      {required PlatformInt64 gameId});

  Future<String> crateApiSimpleGetGameVersion({required PlatformInt64 gameId});

  Future<GamesDbInfoDto> crateApiSimpleGetGamesdbInfo(
      {required PlatformInt64 gameId});

  Future<String> crateApiSimpleGetInstallDir();

  Future<bool> crateApiSimpleGetKeepInstallers();

  Future<String> crateApiSimpleGetLanguage();

  Future<List<GameDto>> crateApiSimpleGetLibrary();

  String crateApiSimpleGetLoginUrl();

  String crateApiSimpleGetRedirectUrl();

  Future<bool> crateApiSimpleGetShowWindowsGames();

  String crateApiSimpleGetSuccessUrl();

  List<(String, String)> crateApiSimpleGetSupportedLanguages();

  List<(String, String)> crateApiSimpleGetSupportedLocales();

  Future<UserDataDto> crateApiSimpleGetUserData();

  Future<String> crateApiSimpleGetViewMode();

  List<(String, String)> crateApiSimpleGetViewModes();

  String crateApiSimpleGreet({required String name});

  Future<void> crateApiSimpleInitApp();

  Future<void> crateApiSimpleInstallDlc(
      {required PlatformInt64 gameId, required String dlcInstallerPath});

  Future<GameDto> crateApiSimpleInstallGame(
      {required PlatformInt64 gameId, required String installerPath});

  Future<bool> crateApiSimpleIsLoggedIn();

  Future<LaunchResultDto> crateApiSimpleLaunchGame(
      {required PlatformInt64 gameId});

  Future<LaunchResultDto> crateApiSimpleLaunchGameAsync(
      {required PlatformInt64 gameId});

  Future<void> crateApiSimpleLogout();

  Future<void> crateApiSimpleOpenWineConfig({required PlatformInt64 gameId});

  Future<void> crateApiSimpleOpenWineRegedit({required PlatformInt64 gameId});

  Future<void> crateApiSimpleOpenWinetricks({required PlatformInt64 gameId});

  Future<void> crateApiSimplePauseDownload({required PlatformInt64 gameId});

  Future<void> crateApiSimpleRemoveAccount({required String userId});

  Future<void> crateApiSimpleSetDarkTheme({required bool enabled});

  Future<void> crateApiSimpleSetInstallDir({required String dir});

  Future<void> crateApiSimpleSetKeepInstallers({required bool enabled});

  Future<void> crateApiSimpleSetLanguage({required String lang});

  Future<void> crateApiSimpleSetShowWindowsGames({required bool enabled});

  Future<void> crateApiSimpleSetViewMode({required String view});

  Future<void> crateApiSimpleStartDownload({required PlatformInt64 gameId});

  Future<bool> crateApiSimpleSwitchAccount({required String userId});

  Future<void> crateApiSimpleUninstallGame({required PlatformInt64 gameId});

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_DownloadManager;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_DownloadManager;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_DownloadManagerPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Game;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Game;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_GamePtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<DownloadManager> crateApiDownloadDownloadManagerDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDownloadManager,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDownloadDownloadManagerDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDownloadDownloadManagerDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "DownloadManager_default",
        argNames: [],
      );

  @override
  String crateApiGameGameAutoAccessorGetCategory({required Game that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorGetCategoryConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorGetCategoryConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_get_category",
        argNames: ["that"],
      );

  @override
  List<Dlc> crateApiGameGameAutoAccessorGetDlcs({required Game that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_dlc,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorGetDlcsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorGetDlcsConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_get_dlcs",
        argNames: ["that"],
      );

  @override
  PlatformInt64 crateApiGameGameAutoAccessorGetId({required Game that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorGetIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorGetIdConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_get_id",
        argNames: ["that"],
      );

  @override
  String crateApiGameGameAutoAccessorGetImageUrl({required Game that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorGetImageUrlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorGetImageUrlConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_get_image_url",
        argNames: ["that"],
      );

  @override
  String crateApiGameGameAutoAccessorGetInstallDir({required Game that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorGetInstallDirConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorGetInstallDirConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_get_install_dir",
        argNames: ["that"],
      );

  @override
  Map<String, String> crateApiGameGameAutoAccessorGetMd5Sum(
      {required Game that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 7)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Map_String_String_None,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorGetMd5SumConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorGetMd5SumConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_get_md5sum",
        argNames: ["that"],
      );

  @override
  String crateApiGameGameAutoAccessorGetName({required Game that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 8)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorGetNameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorGetNameConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_get_name",
        argNames: ["that"],
      );

  @override
  String crateApiGameGameAutoAccessorGetPlatform({required Game that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorGetPlatformConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorGetPlatformConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_get_platform",
        argNames: ["that"],
      );

  @override
  String crateApiGameGameAutoAccessorGetUrl({required Game that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 10)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorGetUrlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorGetUrlConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_get_url",
        argNames: ["that"],
      );

  @override
  void crateApiGameGameAutoAccessorSetCategory(
      {required Game that, required String category}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        sse_encode_String(category, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 11)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorSetCategoryConstMeta,
      argValues: [that, category],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorSetCategoryConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_set_category",
        argNames: ["that", "category"],
      );

  @override
  void crateApiGameGameAutoAccessorSetDlcs(
      {required Game that, required List<Dlc> dlcs}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        sse_encode_list_dlc(dlcs, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 12)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorSetDlcsConstMeta,
      argValues: [that, dlcs],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorSetDlcsConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_set_dlcs",
        argNames: ["that", "dlcs"],
      );

  @override
  void crateApiGameGameAutoAccessorSetId(
      {required Game that, required PlatformInt64 id}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        sse_encode_i_64(id, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 13)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorSetIdConstMeta,
      argValues: [that, id],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorSetIdConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_set_id",
        argNames: ["that", "id"],
      );

  @override
  void crateApiGameGameAutoAccessorSetImageUrl(
      {required Game that, required String imageUrl}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        sse_encode_String(imageUrl, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 14)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorSetImageUrlConstMeta,
      argValues: [that, imageUrl],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorSetImageUrlConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_set_image_url",
        argNames: ["that", "imageUrl"],
      );

  @override
  void crateApiGameGameAutoAccessorSetInstallDir(
      {required Game that, required String installDir}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        sse_encode_String(installDir, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorSetInstallDirConstMeta,
      argValues: [that, installDir],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorSetInstallDirConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_set_install_dir",
        argNames: ["that", "installDir"],
      );

  @override
  void crateApiGameGameAutoAccessorSetMd5Sum(
      {required Game that, required Map<String, String> md5Sum}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        sse_encode_Map_String_String_None(md5Sum, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 16)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorSetMd5SumConstMeta,
      argValues: [that, md5Sum],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorSetMd5SumConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_set_md5sum",
        argNames: ["that", "md5Sum"],
      );

  @override
  void crateApiGameGameAutoAccessorSetName(
      {required Game that, required String name}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        sse_encode_String(name, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 17)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorSetNameConstMeta,
      argValues: [that, name],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorSetNameConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_set_name",
        argNames: ["that", "name"],
      );

  @override
  void crateApiGameGameAutoAccessorSetPlatform(
      {required Game that, required String platform}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        sse_encode_String(platform, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 18)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorSetPlatformConstMeta,
      argValues: [that, platform],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorSetPlatformConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_set_platform",
        argNames: ["that", "platform"],
      );

  @override
  void crateApiGameGameAutoAccessorSetUrl(
      {required Game that, required String url}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
            that, serializer);
        sse_encode_String(url, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 19)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameAutoAccessorSetUrlConstMeta,
      argValues: [that, url],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameAutoAccessorSetUrlConstMeta =>
      const TaskConstMeta(
        debugName: "Game_auto_accessor_set_url",
        argNames: ["that", "url"],
      );

  @override
  Future<AccountManager> crateApiAccountAccountManagerDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_account_manager,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiAccountAccountManagerDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiAccountAccountManagerDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "account_manager_default",
        argNames: [],
      );

  @override
  Future<AccountDto> crateApiSimpleAddCurrentAccount(
      {required String refreshToken}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(refreshToken, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_account_dto,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleAddCurrentAccountConstMeta,
      argValues: [refreshToken],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleAddCurrentAccountConstMeta =>
      const TaskConstMeta(
        debugName: "add_current_account",
        argNames: ["refreshToken"],
      );

  @override
  Future<String> crateApiSimpleAuthenticate(
      {String? loginCode, String? refreshToken}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_opt_String(loginCode, serializer);
        sse_encode_opt_String(refreshToken, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleAuthenticateConstMeta,
      argValues: [loginCode, refreshToken],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleAuthenticateConstMeta => const TaskConstMeta(
        debugName: "authenticate",
        argNames: ["loginCode", "refreshToken"],
      );

  @override
  Future<bool> crateApiSimpleCanConnect() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleCanConnectConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleCanConnectConstMeta => const TaskConstMeta(
        debugName: "can_connect",
        argNames: [],
      );

  @override
  Future<void> crateApiSimpleCancelDownload({required PlatformInt64 gameId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(gameId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleCancelDownloadConstMeta,
      argValues: [gameId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleCancelDownloadConstMeta =>
      const TaskConstMeta(
        debugName: "cancel_download",
        argNames: ["gameId"],
      );

  @override
  Future<bool> crateApiSimpleCheckForUpdate({required PlatformInt64 gameId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(gameId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleCheckForUpdateConstMeta,
      argValues: [gameId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleCheckForUpdateConstMeta =>
      const TaskConstMeta(
        debugName: "check_for_update",
        argNames: ["gameId"],
      );

  @override
  Future<Config> crateApiConfigConfigDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_config,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiConfigConfigDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiConfigConfigDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "config_default",
        argNames: [],
      );

  @override
  Future<DlcInfo> crateApiGameDlcInfoDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_dlc_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameDlcInfoDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameDlcInfoDefaultConstMeta => const TaskConstMeta(
        debugName: "dlc_info_default",
        argNames: [],
      );

  @override
  Future<GameInfo> crateApiGameGameInfoDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_game_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGameGameInfoDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGameGameInfoDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "game_info_default",
        argNames: [],
      );

  @override
  Future<AccountDto?> crateApiSimpleGetActiveAccount() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_account_dto,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetActiveAccountConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetActiveAccountConstMeta =>
      const TaskConstMeta(
        debugName: "get_active_account",
        argNames: [],
      );

  @override
  Future<List<DownloadProgressDto>> crateApiSimpleGetActiveDownloads() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_download_progress_dto,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetActiveDownloadsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetActiveDownloadsConstMeta =>
      const TaskConstMeta(
        debugName: "get_active_downloads",
        argNames: [],
      );

  @override
  Future<List<AccountDto>> crateApiSimpleGetAllAccounts() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_account_dto,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetAllAccountsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetAllAccountsConstMeta =>
      const TaskConstMeta(
        debugName: "get_all_accounts",
        argNames: [],
      );

  @override
  Future<ConfigDto> crateApiSimpleGetConfig() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_config_dto,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetConfigConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetConfigConstMeta => const TaskConstMeta(
        debugName: "get_config",
        argNames: [],
      );

  @override
  Future<bool> crateApiSimpleGetDarkTheme() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetDarkThemeConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetDarkThemeConstMeta => const TaskConstMeta(
        debugName: "get_dark_theme",
        argNames: [],
      );

  @override
  Future<DownloadProgressDto?> crateApiSimpleGetDownloadProgress(
      {required PlatformInt64 gameId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(gameId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_download_progress_dto,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetDownloadProgressConstMeta,
      argValues: [gameId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetDownloadProgressConstMeta =>
      const TaskConstMeta(
        debugName: "get_download_progress",
        argNames: ["gameId"],
      );

  @override
  Future<GameInfoDto> crateApiSimpleGetGameInfo(
      {required PlatformInt64 gameId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(gameId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_game_info_dto,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetGameInfoConstMeta,
      argValues: [gameId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetGameInfoConstMeta => const TaskConstMeta(
        debugName: "get_game_info",
        argNames: ["gameId"],
      );

  @override
  Future<String> crateApiSimpleGetGameVersion({required PlatformInt64 gameId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(gameId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetGameVersionConstMeta,
      argValues: [gameId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetGameVersionConstMeta =>
      const TaskConstMeta(
        debugName: "get_game_version",
        argNames: ["gameId"],
      );

  @override
  Future<GamesDbInfoDto> crateApiSimpleGetGamesdbInfo(
      {required PlatformInt64 gameId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(gameId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_games_db_info_dto,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetGamesdbInfoConstMeta,
      argValues: [gameId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetGamesdbInfoConstMeta =>
      const TaskConstMeta(
        debugName: "get_gamesdb_info",
        argNames: ["gameId"],
      );

  @override
  Future<String> crateApiSimpleGetInstallDir() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 38, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetInstallDirConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetInstallDirConstMeta =>
      const TaskConstMeta(
        debugName: "get_install_dir",
        argNames: [],
      );

  @override
  Future<bool> crateApiSimpleGetKeepInstallers() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 39, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetKeepInstallersConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetKeepInstallersConstMeta =>
      const TaskConstMeta(
        debugName: "get_keep_installers",
        argNames: [],
      );

  @override
  Future<String> crateApiSimpleGetLanguage() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 40, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetLanguageConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetLanguageConstMeta => const TaskConstMeta(
        debugName: "get_language",
        argNames: [],
      );

  @override
  Future<List<GameDto>> crateApiSimpleGetLibrary() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 41, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_game_dto,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetLibraryConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetLibraryConstMeta => const TaskConstMeta(
        debugName: "get_library",
        argNames: [],
      );

  @override
  String crateApiSimpleGetLoginUrl() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 42)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleGetLoginUrlConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetLoginUrlConstMeta => const TaskConstMeta(
        debugName: "get_login_url",
        argNames: [],
      );

  @override
  String crateApiSimpleGetRedirectUrl() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 43)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleGetRedirectUrlConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetRedirectUrlConstMeta =>
      const TaskConstMeta(
        debugName: "get_redirect_url",
        argNames: [],
      );

  @override
  Future<bool> crateApiSimpleGetShowWindowsGames() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 44, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetShowWindowsGamesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetShowWindowsGamesConstMeta =>
      const TaskConstMeta(
        debugName: "get_show_windows_games",
        argNames: [],
      );

  @override
  String crateApiSimpleGetSuccessUrl() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 45)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleGetSuccessUrlConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetSuccessUrlConstMeta =>
      const TaskConstMeta(
        debugName: "get_success_url",
        argNames: [],
      );

  @override
  List<(String, String)> crateApiSimpleGetSupportedLanguages() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 46)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_record_string_string,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleGetSupportedLanguagesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetSupportedLanguagesConstMeta =>
      const TaskConstMeta(
        debugName: "get_supported_languages",
        argNames: [],
      );

  @override
  List<(String, String)> crateApiSimpleGetSupportedLocales() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 47)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_record_string_string,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleGetSupportedLocalesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetSupportedLocalesConstMeta =>
      const TaskConstMeta(
        debugName: "get_supported_locales",
        argNames: [],
      );

  @override
  Future<UserDataDto> crateApiSimpleGetUserData() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 48, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_user_data_dto,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetUserDataConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetUserDataConstMeta => const TaskConstMeta(
        debugName: "get_user_data",
        argNames: [],
      );

  @override
  Future<String> crateApiSimpleGetViewMode() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 49, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetViewModeConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetViewModeConstMeta => const TaskConstMeta(
        debugName: "get_view_mode",
        argNames: [],
      );

  @override
  List<(String, String)> crateApiSimpleGetViewModes() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 50)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_record_string_string,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleGetViewModesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetViewModesConstMeta => const TaskConstMeta(
        debugName: "get_view_modes",
        argNames: [],
      );

  @override
  String crateApiSimpleGreet({required String name}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(name, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 51)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleGreetConstMeta,
      argValues: [name],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGreetConstMeta => const TaskConstMeta(
        debugName: "greet",
        argNames: ["name"],
      );

  @override
  Future<void> crateApiSimpleInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 52, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Future<void> crateApiSimpleInstallDlc(
      {required PlatformInt64 gameId, required String dlcInstallerPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(gameId, serializer);
        sse_encode_String(dlcInstallerPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 53, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleInstallDlcConstMeta,
      argValues: [gameId, dlcInstallerPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleInstallDlcConstMeta => const TaskConstMeta(
        debugName: "install_dlc",
        argNames: ["gameId", "dlcInstallerPath"],
      );

  @override
  Future<GameDto> crateApiSimpleInstallGame(
      {required PlatformInt64 gameId, required String installerPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(gameId, serializer);
        sse_encode_String(installerPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 54, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_game_dto,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleInstallGameConstMeta,
      argValues: [gameId, installerPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleInstallGameConstMeta => const TaskConstMeta(
        debugName: "install_game",
        argNames: ["gameId", "installerPath"],
      );

  @override
  Future<bool> crateApiSimpleIsLoggedIn() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 55, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleIsLoggedInConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleIsLoggedInConstMeta => const TaskConstMeta(
        debugName: "is_logged_in",
        argNames: [],
      );

  @override
  Future<LaunchResultDto> crateApiSimpleLaunchGame(
      {required PlatformInt64 gameId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(gameId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 56, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_launch_result_dto,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleLaunchGameConstMeta,
      argValues: [gameId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleLaunchGameConstMeta => const TaskConstMeta(
        debugName: "launch_game",
        argNames: ["gameId"],
      );

  @override
  Future<LaunchResultDto> crateApiSimpleLaunchGameAsync(
      {required PlatformInt64 gameId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(gameId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 57, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_launch_result_dto,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleLaunchGameAsyncConstMeta,
      argValues: [gameId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleLaunchGameAsyncConstMeta =>
      const TaskConstMeta(
        debugName: "launch_game_async",
        argNames: ["gameId"],
      );

  @override
  Future<void> crateApiSimpleLogout() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 58, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleLogoutConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleLogoutConstMeta => const TaskConstMeta(
        debugName: "logout",
        argNames: [],
      );

  @override
  Future<void> crateApiSimpleOpenWineConfig({required PlatformInt64 gameId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(gameId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 59, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleOpenWineConfigConstMeta,
      argValues: [gameId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleOpenWineConfigConstMeta =>
      const TaskConstMeta(
        debugName: "open_wine_config",
        argNames: ["gameId"],
      );

  @override
  Future<void> crateApiSimpleOpenWineRegedit({required PlatformInt64 gameId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(gameId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 60, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleOpenWineRegeditConstMeta,
      argValues: [gameId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleOpenWineRegeditConstMeta =>
      const TaskConstMeta(
        debugName: "open_wine_regedit",
        argNames: ["gameId"],
      );

  @override
  Future<void> crateApiSimpleOpenWinetricks({required PlatformInt64 gameId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(gameId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 61, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleOpenWinetricksConstMeta,
      argValues: [gameId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleOpenWinetricksConstMeta =>
      const TaskConstMeta(
        debugName: "open_winetricks",
        argNames: ["gameId"],
      );

  @override
  Future<void> crateApiSimplePauseDownload({required PlatformInt64 gameId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(gameId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 62, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimplePauseDownloadConstMeta,
      argValues: [gameId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimplePauseDownloadConstMeta =>
      const TaskConstMeta(
        debugName: "pause_download",
        argNames: ["gameId"],
      );

  @override
  Future<void> crateApiSimpleRemoveAccount({required String userId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(userId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 63, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleRemoveAccountConstMeta,
      argValues: [userId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleRemoveAccountConstMeta =>
      const TaskConstMeta(
        debugName: "remove_account",
        argNames: ["userId"],
      );

  @override
  Future<void> crateApiSimpleSetDarkTheme({required bool enabled}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_bool(enabled, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 64, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleSetDarkThemeConstMeta,
      argValues: [enabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleSetDarkThemeConstMeta => const TaskConstMeta(
        debugName: "set_dark_theme",
        argNames: ["enabled"],
      );

  @override
  Future<void> crateApiSimpleSetInstallDir({required String dir}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dir, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 65, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleSetInstallDirConstMeta,
      argValues: [dir],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleSetInstallDirConstMeta =>
      const TaskConstMeta(
        debugName: "set_install_dir",
        argNames: ["dir"],
      );

  @override
  Future<void> crateApiSimpleSetKeepInstallers({required bool enabled}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_bool(enabled, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 66, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleSetKeepInstallersConstMeta,
      argValues: [enabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleSetKeepInstallersConstMeta =>
      const TaskConstMeta(
        debugName: "set_keep_installers",
        argNames: ["enabled"],
      );

  @override
  Future<void> crateApiSimpleSetLanguage({required String lang}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(lang, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 67, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleSetLanguageConstMeta,
      argValues: [lang],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleSetLanguageConstMeta => const TaskConstMeta(
        debugName: "set_language",
        argNames: ["lang"],
      );

  @override
  Future<void> crateApiSimpleSetShowWindowsGames({required bool enabled}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_bool(enabled, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 68, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleSetShowWindowsGamesConstMeta,
      argValues: [enabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleSetShowWindowsGamesConstMeta =>
      const TaskConstMeta(
        debugName: "set_show_windows_games",
        argNames: ["enabled"],
      );

  @override
  Future<void> crateApiSimpleSetViewMode({required String view}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(view, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 69, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleSetViewModeConstMeta,
      argValues: [view],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleSetViewModeConstMeta => const TaskConstMeta(
        debugName: "set_view_mode",
        argNames: ["view"],
      );

  @override
  Future<void> crateApiSimpleStartDownload({required PlatformInt64 gameId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(gameId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 70, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleStartDownloadConstMeta,
      argValues: [gameId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleStartDownloadConstMeta =>
      const TaskConstMeta(
        debugName: "start_download",
        argNames: ["gameId"],
      );

  @override
  Future<bool> crateApiSimpleSwitchAccount({required String userId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(userId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 71, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleSwitchAccountConstMeta,
      argValues: [userId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleSwitchAccountConstMeta =>
      const TaskConstMeta(
        debugName: "switch_account",
        argNames: ["userId"],
      );

  @override
  Future<void> crateApiSimpleUninstallGame({required PlatformInt64 gameId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_64(gameId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 72, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleUninstallGameConstMeta,
      argValues: [gameId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleUninstallGameConstMeta =>
      const TaskConstMeta(
        debugName: "uninstall_game",
        argNames: ["gameId"],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_DownloadManager => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDownloadManager;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_DownloadManager => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDownloadManager;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Game =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Game =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  DownloadManager
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDownloadManager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DownloadManagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Game
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GameImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Game
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GameImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Game
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GameImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Map<String, String> dco_decode_Map_String_String_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_string(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<String, DlcInfo> dco_decode_Map_String_dlc_info_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_dlc_info(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<String, BigInt> dco_decode_Map_String_u_64_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_u_64(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  DownloadManager
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDownloadManager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DownloadManagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Game
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GameImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  Account dco_decode_account(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return Account(
      userId: dco_decode_String(arr[0]),
      username: dco_decode_String(arr[1]),
      email: dco_decode_opt_String(arr[2]),
      avatarUrl: dco_decode_opt_String(arr[3]),
      refreshToken: dco_decode_String(arr[4]),
      addedAt: dco_decode_String(arr[5]),
      lastLogin: dco_decode_opt_String(arr[6]),
    );
  }

  @protected
  AccountDto dco_decode_account_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return AccountDto(
      userId: dco_decode_String(arr[0]),
      username: dco_decode_String(arr[1]),
      refreshToken: dco_decode_String(arr[2]),
      avatarUrl: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  AccountManager dco_decode_account_manager(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AccountManager(
      accounts: dco_decode_list_account(arr[0]),
      activeAccountId: dco_decode_opt_String(arr[1]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  AccountDto dco_decode_box_autoadd_account_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_account_dto(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  DownloadProgressDto dco_decode_box_autoadd_download_progress_dto(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_download_progress_dto(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  Config dco_decode_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 18)
      throw Exception('unexpected arr length: expect 18 but see ${arr.length}');
    return Config(
      locale: dco_decode_String(arr[0]),
      lang: dco_decode_String(arr[1]),
      view: dco_decode_String(arr[2]),
      installDir: dco_decode_String(arr[3]),
      username: dco_decode_String(arr[4]),
      refreshToken: dco_decode_String(arr[5]),
      keepInstallers: dco_decode_bool(arr[6]),
      stayLoggedIn: dco_decode_bool(arr[7]),
      useDarkTheme: dco_decode_bool(arr[8]),
      showHiddenGames: dco_decode_bool(arr[9]),
      showWindowsGames: dco_decode_bool(arr[10]),
      keepWindowMaximized: dco_decode_bool(arr[11]),
      installedFilter: dco_decode_bool(arr[12]),
      createApplicationsFile: dco_decode_bool(arr[13]),
      maxParallelGameDownloads: dco_decode_i_32(arr[14]),
      currentDownloads: dco_decode_list_prim_i_64_strict(arr[15]),
      pausedDownloads: dco_decode_Map_String_u_64_None(arr[16]),
      activeAccountId: dco_decode_opt_String(arr[17]),
    );
  }

  @protected
  ConfigDto dco_decode_config_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return ConfigDto(
      locale: dco_decode_String(arr[0]),
      lang: dco_decode_String(arr[1]),
      view: dco_decode_String(arr[2]),
      installDir: dco_decode_String(arr[3]),
      keepInstallers: dco_decode_bool(arr[4]),
      stayLoggedIn: dco_decode_bool(arr[5]),
      useDarkTheme: dco_decode_bool(arr[6]),
      showHiddenGames: dco_decode_bool(arr[7]),
      showWindowsGames: dco_decode_bool(arr[8]),
    );
  }

  @protected
  Dlc dco_decode_dlc(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return Dlc(
      id: dco_decode_i_64(arr[0]),
      name: dco_decode_String(arr[1]),
      title: dco_decode_String(arr[2]),
      imageUrl: dco_decode_String(arr[3]),
    );
  }

  @protected
  DlcDto dco_decode_dlc_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return DlcDto(
      id: dco_decode_i_64(arr[0]),
      name: dco_decode_String(arr[1]),
      title: dco_decode_String(arr[2]),
      imageUrl: dco_decode_String(arr[3]),
    );
  }

  @protected
  DlcInfo dco_decode_dlc_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return DlcInfo(
      version: dco_decode_opt_String(arr[0]),
    );
  }

  @protected
  DownloadProgressDto dco_decode_download_progress_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return DownloadProgressDto(
      gameId: dco_decode_i_64(arr[0]),
      gameName: dco_decode_String(arr[1]),
      downloadedBytes: dco_decode_u_64(arr[2]),
      totalBytes: dco_decode_u_64(arr[3]),
      speedBytesPerSec: dco_decode_u_64(arr[4]),
      status: dco_decode_String(arr[5]),
    );
  }

  @protected
  GameDto dco_decode_game_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return GameDto(
      id: dco_decode_i_64(arr[0]),
      name: dco_decode_String(arr[1]),
      url: dco_decode_String(arr[2]),
      installDir: dco_decode_String(arr[3]),
      imageUrl: dco_decode_String(arr[4]),
      platform: dco_decode_String(arr[5]),
      category: dco_decode_String(arr[6]),
      dlcs: dco_decode_list_dlc_dto(arr[7]),
    );
  }

  @protected
  GameInfo dco_decode_game_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return GameInfo(
      version: dco_decode_opt_String(arr[0]),
      dlcs: dco_decode_Map_String_dlc_info_None(arr[1]),
      showFps: dco_decode_opt_box_autoadd_bool(arr[2]),
      useGamemode: dco_decode_opt_box_autoadd_bool(arr[3]),
      useMangohud: dco_decode_opt_box_autoadd_bool(arr[4]),
      variable: dco_decode_opt_String(arr[5]),
      command: dco_decode_opt_String(arr[6]),
      customWine: dco_decode_opt_String(arr[7]),
      hidden: dco_decode_opt_box_autoadd_bool(arr[8]),
    );
  }

  @protected
  GameInfoDto dco_decode_game_info_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return GameInfoDto(
      id: dco_decode_i_64(arr[0]),
      title: dco_decode_String(arr[1]),
      description: dco_decode_opt_String(arr[2]),
      changelog: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  GamesDbInfoDto dco_decode_games_db_info_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return GamesDbInfoDto(
      cover: dco_decode_String(arr[0]),
      verticalCover: dco_decode_String(arr[1]),
      background: dco_decode_String(arr[2]),
      summary: dco_decode_String(arr[3]),
      genre: dco_decode_String(arr[4]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  LaunchResultDto dco_decode_launch_result_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return LaunchResultDto(
      success: dco_decode_bool(arr[0]),
      errorMessage: dco_decode_opt_String(arr[1]),
      pid: dco_decode_opt_box_autoadd_u_32(arr[2]),
    );
  }

  @protected
  List<Account> dco_decode_list_account(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_account).toList();
  }

  @protected
  List<AccountDto> dco_decode_list_account_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_account_dto).toList();
  }

  @protected
  List<Dlc> dco_decode_list_dlc(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_dlc).toList();
  }

  @protected
  List<DlcDto> dco_decode_list_dlc_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_dlc_dto).toList();
  }

  @protected
  List<DownloadProgressDto> dco_decode_list_download_progress_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_download_progress_dto)
        .toList();
  }

  @protected
  List<GameDto> dco_decode_list_game_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_game_dto).toList();
  }

  @protected
  Int64List dco_decode_list_prim_i_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeInt64List(raw);
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(String, DlcInfo)> dco_decode_list_record_string_dlc_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_string_dlc_info)
        .toList();
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  List<(String, BigInt)> dco_decode_list_record_string_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_u_64).toList();
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  AccountDto? dco_decode_opt_box_autoadd_account_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_account_dto(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  DownloadProgressDto? dco_decode_opt_box_autoadd_download_progress_dto(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_download_progress_dto(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  (String, DlcInfo) dco_decode_record_string_dlc_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_dlc_info(arr[1]),
    );
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_String(arr[1]),
    );
  }

  @protected
  (String, BigInt) dco_decode_record_string_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_u_64(arr[1]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  UserDataDto dco_decode_user_data_dto(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return UserDataDto(
      userId: dco_decode_String(arr[0]),
      username: dco_decode_String(arr[1]),
      email: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  DownloadManager
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDownloadManager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DownloadManagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Game
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GameImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Game
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GameImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Game
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GameImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Map<String, String> sse_decode_Map_String_String_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_string(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<String, DlcInfo> sse_decode_Map_String_dlc_info_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_dlc_info(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<String, BigInt> sse_decode_Map_String_u_64_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_u_64(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  DownloadManager
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDownloadManager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DownloadManagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Game
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GameImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  Account sse_decode_account(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_userId = sse_decode_String(deserializer);
    var var_username = sse_decode_String(deserializer);
    var var_email = sse_decode_opt_String(deserializer);
    var var_avatarUrl = sse_decode_opt_String(deserializer);
    var var_refreshToken = sse_decode_String(deserializer);
    var var_addedAt = sse_decode_String(deserializer);
    var var_lastLogin = sse_decode_opt_String(deserializer);
    return Account(
        userId: var_userId,
        username: var_username,
        email: var_email,
        avatarUrl: var_avatarUrl,
        refreshToken: var_refreshToken,
        addedAt: var_addedAt,
        lastLogin: var_lastLogin);
  }

  @protected
  AccountDto sse_decode_account_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_userId = sse_decode_String(deserializer);
    var var_username = sse_decode_String(deserializer);
    var var_refreshToken = sse_decode_String(deserializer);
    var var_avatarUrl = sse_decode_opt_String(deserializer);
    return AccountDto(
        userId: var_userId,
        username: var_username,
        refreshToken: var_refreshToken,
        avatarUrl: var_avatarUrl);
  }

  @protected
  AccountManager sse_decode_account_manager(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_accounts = sse_decode_list_account(deserializer);
    var var_activeAccountId = sse_decode_opt_String(deserializer);
    return AccountManager(
        accounts: var_accounts, activeAccountId: var_activeAccountId);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  AccountDto sse_decode_box_autoadd_account_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_account_dto(deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  DownloadProgressDto sse_decode_box_autoadd_download_progress_dto(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_download_progress_dto(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  Config sse_decode_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_locale = sse_decode_String(deserializer);
    var var_lang = sse_decode_String(deserializer);
    var var_view = sse_decode_String(deserializer);
    var var_installDir = sse_decode_String(deserializer);
    var var_username = sse_decode_String(deserializer);
    var var_refreshToken = sse_decode_String(deserializer);
    var var_keepInstallers = sse_decode_bool(deserializer);
    var var_stayLoggedIn = sse_decode_bool(deserializer);
    var var_useDarkTheme = sse_decode_bool(deserializer);
    var var_showHiddenGames = sse_decode_bool(deserializer);
    var var_showWindowsGames = sse_decode_bool(deserializer);
    var var_keepWindowMaximized = sse_decode_bool(deserializer);
    var var_installedFilter = sse_decode_bool(deserializer);
    var var_createApplicationsFile = sse_decode_bool(deserializer);
    var var_maxParallelGameDownloads = sse_decode_i_32(deserializer);
    var var_currentDownloads = sse_decode_list_prim_i_64_strict(deserializer);
    var var_pausedDownloads = sse_decode_Map_String_u_64_None(deserializer);
    var var_activeAccountId = sse_decode_opt_String(deserializer);
    return Config(
        locale: var_locale,
        lang: var_lang,
        view: var_view,
        installDir: var_installDir,
        username: var_username,
        refreshToken: var_refreshToken,
        keepInstallers: var_keepInstallers,
        stayLoggedIn: var_stayLoggedIn,
        useDarkTheme: var_useDarkTheme,
        showHiddenGames: var_showHiddenGames,
        showWindowsGames: var_showWindowsGames,
        keepWindowMaximized: var_keepWindowMaximized,
        installedFilter: var_installedFilter,
        createApplicationsFile: var_createApplicationsFile,
        maxParallelGameDownloads: var_maxParallelGameDownloads,
        currentDownloads: var_currentDownloads,
        pausedDownloads: var_pausedDownloads,
        activeAccountId: var_activeAccountId);
  }

  @protected
  ConfigDto sse_decode_config_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_locale = sse_decode_String(deserializer);
    var var_lang = sse_decode_String(deserializer);
    var var_view = sse_decode_String(deserializer);
    var var_installDir = sse_decode_String(deserializer);
    var var_keepInstallers = sse_decode_bool(deserializer);
    var var_stayLoggedIn = sse_decode_bool(deserializer);
    var var_useDarkTheme = sse_decode_bool(deserializer);
    var var_showHiddenGames = sse_decode_bool(deserializer);
    var var_showWindowsGames = sse_decode_bool(deserializer);
    return ConfigDto(
        locale: var_locale,
        lang: var_lang,
        view: var_view,
        installDir: var_installDir,
        keepInstallers: var_keepInstallers,
        stayLoggedIn: var_stayLoggedIn,
        useDarkTheme: var_useDarkTheme,
        showHiddenGames: var_showHiddenGames,
        showWindowsGames: var_showWindowsGames);
  }

  @protected
  Dlc sse_decode_dlc(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_64(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_imageUrl = sse_decode_String(deserializer);
    return Dlc(
        id: var_id, name: var_name, title: var_title, imageUrl: var_imageUrl);
  }

  @protected
  DlcDto sse_decode_dlc_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_64(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_imageUrl = sse_decode_String(deserializer);
    return DlcDto(
        id: var_id, name: var_name, title: var_title, imageUrl: var_imageUrl);
  }

  @protected
  DlcInfo sse_decode_dlc_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_version = sse_decode_opt_String(deserializer);
    return DlcInfo(version: var_version);
  }

  @protected
  DownloadProgressDto sse_decode_download_progress_dto(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_gameId = sse_decode_i_64(deserializer);
    var var_gameName = sse_decode_String(deserializer);
    var var_downloadedBytes = sse_decode_u_64(deserializer);
    var var_totalBytes = sse_decode_u_64(deserializer);
    var var_speedBytesPerSec = sse_decode_u_64(deserializer);
    var var_status = sse_decode_String(deserializer);
    return DownloadProgressDto(
        gameId: var_gameId,
        gameName: var_gameName,
        downloadedBytes: var_downloadedBytes,
        totalBytes: var_totalBytes,
        speedBytesPerSec: var_speedBytesPerSec,
        status: var_status);
  }

  @protected
  GameDto sse_decode_game_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_64(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_installDir = sse_decode_String(deserializer);
    var var_imageUrl = sse_decode_String(deserializer);
    var var_platform = sse_decode_String(deserializer);
    var var_category = sse_decode_String(deserializer);
    var var_dlcs = sse_decode_list_dlc_dto(deserializer);
    return GameDto(
        id: var_id,
        name: var_name,
        url: var_url,
        installDir: var_installDir,
        imageUrl: var_imageUrl,
        platform: var_platform,
        category: var_category,
        dlcs: var_dlcs);
  }

  @protected
  GameInfo sse_decode_game_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_version = sse_decode_opt_String(deserializer);
    var var_dlcs = sse_decode_Map_String_dlc_info_None(deserializer);
    var var_showFps = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_useGamemode = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_useMangohud = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_variable = sse_decode_opt_String(deserializer);
    var var_command = sse_decode_opt_String(deserializer);
    var var_customWine = sse_decode_opt_String(deserializer);
    var var_hidden = sse_decode_opt_box_autoadd_bool(deserializer);
    return GameInfo(
        version: var_version,
        dlcs: var_dlcs,
        showFps: var_showFps,
        useGamemode: var_useGamemode,
        useMangohud: var_useMangohud,
        variable: var_variable,
        command: var_command,
        customWine: var_customWine,
        hidden: var_hidden);
  }

  @protected
  GameInfoDto sse_decode_game_info_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_64(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_changelog = sse_decode_opt_String(deserializer);
    return GameInfoDto(
        id: var_id,
        title: var_title,
        description: var_description,
        changelog: var_changelog);
  }

  @protected
  GamesDbInfoDto sse_decode_games_db_info_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_cover = sse_decode_String(deserializer);
    var var_verticalCover = sse_decode_String(deserializer);
    var var_background = sse_decode_String(deserializer);
    var var_summary = sse_decode_String(deserializer);
    var var_genre = sse_decode_String(deserializer);
    return GamesDbInfoDto(
        cover: var_cover,
        verticalCover: var_verticalCover,
        background: var_background,
        summary: var_summary,
        genre: var_genre);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  LaunchResultDto sse_decode_launch_result_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_success = sse_decode_bool(deserializer);
    var var_errorMessage = sse_decode_opt_String(deserializer);
    var var_pid = sse_decode_opt_box_autoadd_u_32(deserializer);
    return LaunchResultDto(
        success: var_success, errorMessage: var_errorMessage, pid: var_pid);
  }

  @protected
  List<Account> sse_decode_list_account(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Account>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_account(deserializer));
    }
    return ans_;
  }

  @protected
  List<AccountDto> sse_decode_list_account_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <AccountDto>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_account_dto(deserializer));
    }
    return ans_;
  }

  @protected
  List<Dlc> sse_decode_list_dlc(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Dlc>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_dlc(deserializer));
    }
    return ans_;
  }

  @protected
  List<DlcDto> sse_decode_list_dlc_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DlcDto>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_dlc_dto(deserializer));
    }
    return ans_;
  }

  @protected
  List<DownloadProgressDto> sse_decode_list_download_progress_dto(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DownloadProgressDto>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_download_progress_dto(deserializer));
    }
    return ans_;
  }

  @protected
  List<GameDto> sse_decode_list_game_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GameDto>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_game_dto(deserializer));
    }
    return ans_;
  }

  @protected
  Int64List sse_decode_list_prim_i_64_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getInt64List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(String, DlcInfo)> sse_decode_list_record_string_dlc_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, DlcInfo)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_dlc_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, BigInt)> sse_decode_list_record_string_u_64(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, BigInt)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_u_64(deserializer));
    }
    return ans_;
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  AccountDto? sse_decode_opt_box_autoadd_account_dto(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_account_dto(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  DownloadProgressDto? sse_decode_opt_box_autoadd_download_progress_dto(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_download_progress_dto(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (String, DlcInfo) sse_decode_record_string_dlc_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_dlc_info(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, String) sse_decode_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, BigInt) sse_decode_record_string_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_u_64(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  UserDataDto sse_decode_user_data_dto(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_userId = sse_decode_String(deserializer);
    var var_username = sse_decode_String(deserializer);
    var var_email = sse_decode_opt_String(deserializer);
    return UserDataDto(
        userId: var_userId, username: var_username, email: var_email);
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDownloadManager(
          DownloadManager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as DownloadManagerImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
          Game self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as GameImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
          Game self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as GameImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
          Game self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as GameImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void sse_encode_Map_String_String_None(
      Map<String, String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_string(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_Map_String_dlc_info_None(
      Map<String, DlcInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_dlc_info(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_Map_String_u_64_None(
      Map<String, BigInt> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_u_64(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDownloadManager(
          DownloadManager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as DownloadManagerImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGame(
          Game self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as GameImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_account(Account self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.userId, serializer);
    sse_encode_String(self.username, serializer);
    sse_encode_opt_String(self.email, serializer);
    sse_encode_opt_String(self.avatarUrl, serializer);
    sse_encode_String(self.refreshToken, serializer);
    sse_encode_String(self.addedAt, serializer);
    sse_encode_opt_String(self.lastLogin, serializer);
  }

  @protected
  void sse_encode_account_dto(AccountDto self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.userId, serializer);
    sse_encode_String(self.username, serializer);
    sse_encode_String(self.refreshToken, serializer);
    sse_encode_opt_String(self.avatarUrl, serializer);
  }

  @protected
  void sse_encode_account_manager(
      AccountManager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_account(self.accounts, serializer);
    sse_encode_opt_String(self.activeAccountId, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_account_dto(
      AccountDto self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_account_dto(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_download_progress_dto(
      DownloadProgressDto self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_download_progress_dto(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_config(Config self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.locale, serializer);
    sse_encode_String(self.lang, serializer);
    sse_encode_String(self.view, serializer);
    sse_encode_String(self.installDir, serializer);
    sse_encode_String(self.username, serializer);
    sse_encode_String(self.refreshToken, serializer);
    sse_encode_bool(self.keepInstallers, serializer);
    sse_encode_bool(self.stayLoggedIn, serializer);
    sse_encode_bool(self.useDarkTheme, serializer);
    sse_encode_bool(self.showHiddenGames, serializer);
    sse_encode_bool(self.showWindowsGames, serializer);
    sse_encode_bool(self.keepWindowMaximized, serializer);
    sse_encode_bool(self.installedFilter, serializer);
    sse_encode_bool(self.createApplicationsFile, serializer);
    sse_encode_i_32(self.maxParallelGameDownloads, serializer);
    sse_encode_list_prim_i_64_strict(self.currentDownloads, serializer);
    sse_encode_Map_String_u_64_None(self.pausedDownloads, serializer);
    sse_encode_opt_String(self.activeAccountId, serializer);
  }

  @protected
  void sse_encode_config_dto(ConfigDto self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.locale, serializer);
    sse_encode_String(self.lang, serializer);
    sse_encode_String(self.view, serializer);
    sse_encode_String(self.installDir, serializer);
    sse_encode_bool(self.keepInstallers, serializer);
    sse_encode_bool(self.stayLoggedIn, serializer);
    sse_encode_bool(self.useDarkTheme, serializer);
    sse_encode_bool(self.showHiddenGames, serializer);
    sse_encode_bool(self.showWindowsGames, serializer);
  }

  @protected
  void sse_encode_dlc(Dlc self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.imageUrl, serializer);
  }

  @protected
  void sse_encode_dlc_dto(DlcDto self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.imageUrl, serializer);
  }

  @protected
  void sse_encode_dlc_info(DlcInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.version, serializer);
  }

  @protected
  void sse_encode_download_progress_dto(
      DownloadProgressDto self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.gameId, serializer);
    sse_encode_String(self.gameName, serializer);
    sse_encode_u_64(self.downloadedBytes, serializer);
    sse_encode_u_64(self.totalBytes, serializer);
    sse_encode_u_64(self.speedBytesPerSec, serializer);
    sse_encode_String(self.status, serializer);
  }

  @protected
  void sse_encode_game_dto(GameDto self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_String(self.installDir, serializer);
    sse_encode_String(self.imageUrl, serializer);
    sse_encode_String(self.platform, serializer);
    sse_encode_String(self.category, serializer);
    sse_encode_list_dlc_dto(self.dlcs, serializer);
  }

  @protected
  void sse_encode_game_info(GameInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.version, serializer);
    sse_encode_Map_String_dlc_info_None(self.dlcs, serializer);
    sse_encode_opt_box_autoadd_bool(self.showFps, serializer);
    sse_encode_opt_box_autoadd_bool(self.useGamemode, serializer);
    sse_encode_opt_box_autoadd_bool(self.useMangohud, serializer);
    sse_encode_opt_String(self.variable, serializer);
    sse_encode_opt_String(self.command, serializer);
    sse_encode_opt_String(self.customWine, serializer);
    sse_encode_opt_box_autoadd_bool(self.hidden, serializer);
  }

  @protected
  void sse_encode_game_info_dto(GameInfoDto self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_opt_String(self.changelog, serializer);
  }

  @protected
  void sse_encode_games_db_info_dto(
      GamesDbInfoDto self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.cover, serializer);
    sse_encode_String(self.verticalCover, serializer);
    sse_encode_String(self.background, serializer);
    sse_encode_String(self.summary, serializer);
    sse_encode_String(self.genre, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_launch_result_dto(
      LaunchResultDto self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.success, serializer);
    sse_encode_opt_String(self.errorMessage, serializer);
    sse_encode_opt_box_autoadd_u_32(self.pid, serializer);
  }

  @protected
  void sse_encode_list_account(List<Account> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_account(item, serializer);
    }
  }

  @protected
  void sse_encode_list_account_dto(
      List<AccountDto> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_account_dto(item, serializer);
    }
  }

  @protected
  void sse_encode_list_dlc(List<Dlc> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_dlc(item, serializer);
    }
  }

  @protected
  void sse_encode_list_dlc_dto(List<DlcDto> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_dlc_dto(item, serializer);
    }
  }

  @protected
  void sse_encode_list_download_progress_dto(
      List<DownloadProgressDto> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_download_progress_dto(item, serializer);
    }
  }

  @protected
  void sse_encode_list_game_dto(List<GameDto> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_game_dto(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_i_64_strict(
      Int64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putInt64List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_string_dlc_info(
      List<(String, DlcInfo)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_dlc_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_string(
      List<(String, String)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_u_64(
      List<(String, BigInt)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_u_64(item, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_account_dto(
      AccountDto? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_account_dto(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_download_progress_dto(
      DownloadProgressDto? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_download_progress_dto(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_record_string_dlc_info(
      (String, DlcInfo) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_dlc_info(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_string(
      (String, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_u_64(
      (String, BigInt) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_u_64(self.$2, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_user_data_dto(UserDataDto self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.userId, serializer);
    sse_encode_String(self.username, serializer);
    sse_encode_opt_String(self.email, serializer);
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}

@sealed
class DownloadManagerImpl extends RustOpaque implements DownloadManager {
  // Not to be used by end users
  DownloadManagerImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  DownloadManagerImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_DownloadManager,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_DownloadManager,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_DownloadManagerPtr,
  );
}

@sealed
class GameImpl extends RustOpaque implements Game {
  // Not to be used by end users
  GameImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  GameImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Game,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Game,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_GamePtr,
  );

  String get category =>
      RustLib.instance.api.crateApiGameGameAutoAccessorGetCategory(
        that: this,
      );

  List<Dlc> get dlcs =>
      RustLib.instance.api.crateApiGameGameAutoAccessorGetDlcs(
        that: this,
      );

  PlatformInt64 get id =>
      RustLib.instance.api.crateApiGameGameAutoAccessorGetId(
        that: this,
      );

  String get imageUrl =>
      RustLib.instance.api.crateApiGameGameAutoAccessorGetImageUrl(
        that: this,
      );

  String get installDir =>
      RustLib.instance.api.crateApiGameGameAutoAccessorGetInstallDir(
        that: this,
      );

  Map<String, String> get md5Sum =>
      RustLib.instance.api.crateApiGameGameAutoAccessorGetMd5Sum(
        that: this,
      );

  String get name => RustLib.instance.api.crateApiGameGameAutoAccessorGetName(
        that: this,
      );

  String get platform =>
      RustLib.instance.api.crateApiGameGameAutoAccessorGetPlatform(
        that: this,
      );

  String get url => RustLib.instance.api.crateApiGameGameAutoAccessorGetUrl(
        that: this,
      );

  set category(String category) => RustLib.instance.api
      .crateApiGameGameAutoAccessorSetCategory(that: this, category: category);

  set dlcs(List<Dlc> dlcs) => RustLib.instance.api
      .crateApiGameGameAutoAccessorSetDlcs(that: this, dlcs: dlcs);

  set id(PlatformInt64 id) => RustLib.instance.api
      .crateApiGameGameAutoAccessorSetId(that: this, id: id);

  set imageUrl(String imageUrl) => RustLib.instance.api
      .crateApiGameGameAutoAccessorSetImageUrl(that: this, imageUrl: imageUrl);

  set installDir(String installDir) =>
      RustLib.instance.api.crateApiGameGameAutoAccessorSetInstallDir(
          that: this, installDir: installDir);

  set md5Sum(Map<String, String> md5Sum) => RustLib.instance.api
      .crateApiGameGameAutoAccessorSetMd5Sum(that: this, md5Sum: md5Sum);

  set name(String name) => RustLib.instance.api
      .crateApiGameGameAutoAccessorSetName(that: this, name: name);

  set platform(String platform) => RustLib.instance.api
      .crateApiGameGameAutoAccessorSetPlatform(that: this, platform: platform);

  set url(String url) => RustLib.instance.api
      .crateApiGameGameAutoAccessorSetUrl(that: this, url: url);
}
